
There's a lot of error checking to do!!!



========================================  Part 1  ========================================  

1. didn't see anyway to improve sys_page_allloc in the `exception` function


========================================  Part 2  ========================================  

1. pageinfo keeps track of who owns a page and how many other pagetables refer to it
   (i think)

2. for part 2 the big goal is to make process_setup create a pagetable, rather than just
   using the kernel's page table

3. let's break this down

    a. first grab 5 free pages
    b. clear them all out
    c. set up your page tables
    d. copy mappings

4. i think what i didn't understand is that essentially, all this code is running in a 
   very privileged mode. That means, while we usually couldn't just assign stuff to 
   certain addresses, now we can. we're building up the abstraction, step by step 

5. This still raises the question of how does this start initially? i understand that the
   code for the kernel is saved to certain pages in memory -- i'm literally doing that 
   mapping, but how does that get started?

   what i'm going to assume is that when the machine was built, the code of the kernel 
   was physically placed into the pages that I reserve for the kernel. Then the setup 
   procedure makes every other process aware of this kind of information

6. I decided to use memcpy. I guessed that all the entries in the first l1 pagetable of
   kernel pagetable were the lower numbered entries

   this is the code I would use if i wasn't using memcpy

    //for (uintptr_t va = 0; va < PROC_START_ADDR; va += PAGESIZE) {
    //    vamapping vm = virtual_memory_lookup(kernel_pagetable, va);
    //    virtual_memory_map(processes[pid].p_pagetable, va, vm.pa, PAGESIZE, vm.perm);
    //}


TODO: Something feels wrong with my next_free page function, i think    

========================================  Part 3  ========================================  

TODO: Something feels wrong with my next_free page function, i think    

1. simply reused the next_free_page function from before

2. the address that weused in sys_page_alloc is now a virtual rather than physical address

========================================  Part 4  ========================================  

1. simply reused same method as in the sys_alloc interrupt

========================================  Part 5  ========================================  
                                           Fork

1. Here's the strategy laidout by the spec
    a. first look for an open slot in processes. if there isn't one, return -1 to caller +
    b. make a copy of the page table, you can use the process_setup function from earlier
        this isn't too hard, but I shouldn't be looking at every single virtual address
        but I'm not sure which ones I need to?


2. what do i do if there's no good pid?
    - return -1 and quit

3. need to make this failure robust, ie cleanup on fork fail -- this suddenly looks very 
   hard
    - i need to check i have room to set up the page table
    - i need to check that i have room for the data mapped to by the pagetable
    - i need to reset the process slot

========================================  Part 6  ========================================  

1. i didn't really get how the linkers and loaders worked so i'm a bit confused rn

2. question -- how can each individual process see other processes getting kernel memory?

3. modifying strategy:
    a. modify fork to recognize shared pages                    +
    b. modify segment loader to use virtual addresses           +
    c. 


========================================  Part 1  ========================================  

1. didn't see anyway to improve sys_page_allloc in the `exception` function


========================================  Part 2  ========================================  

1. pageinfo keeps track of who owns a page and how many other pagetables refer to it
   (i think)

2. for part 2 the big goal is to make process_setup create a pagetable, rather than just
   using the kernel's page table

3. let's break this down

    a. first grab 5 free pages
    b. clear them all out
    c. set up your page tables
    d. copy mappings

4. i think what i didn't understand is that essentially, all this code is running in a 
   very privileged mode. That means, while we usually couldn't just assign stuff to 
   certain addresses, now we can. we're building up the abstraction, step by step 

5. This still raises the question of how does this start initially? i understand that the
   code for the kernel is saved to certain pages in memory -- i'm literally doing that 
   mapping, but how does that get started?

   what i'm going to assume is that when the machine was built, the code of the kernel 
   was physically placed into the pages that I reserve for the kernel. Then the setup 
   procedure makes every other process aware of this kind of information

6. I decided to use memcpy. I guessed that all the entries in the first l1 pagetable of
   kernel pagetable were the lower numbered entries

   this is the code I would use if i wasn't using memcpy

    //for (uintptr_t va = 0; va < PROC_START_ADDR; va += PAGESIZE) {
    //    vamapping vm = virtual_memory_lookup(kernel_pagetable, va);
    //    virtual_memory_map(processes[pid].p_pagetable, va, vm.pa, PAGESIZE, vm.perm);
    //}
